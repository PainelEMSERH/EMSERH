export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

async function ensureEpiEntregasTable() {
  await prisma.$executeRawUnsafe(`
    CREATE TABLE IF NOT EXISTS epi_entregas (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      cpf TEXT NOT NULL,
      item TEXT NOT NULL,
      qty_required INT DEFAULT 1,
      qty_delivered INT DEFAULT 0,
      deliveries JSONB DEFAULT '[]',
      created_at TIMESTAMPTZ DEFAULT now(),
      updated_at TIMESTAMPTZ DEFAULT now(),
      UNIQUE(cpf, item)
    );
  `);
}

async function ensureManualColabTable() {
  await prisma.$executeRawUnsafe(`
    CREATE TABLE IF NOT EXISTS epi_manual_colab (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      cpf TEXT NOT NULL UNIQUE,
      matricula TEXT,
      nome TEXT,
      funcao TEXT,
      unidade TEXT,
      regional TEXT,
      admissao DATE,
      demissao DATE,
      created_at TIMESTAMPTZ DEFAULT now(),
      updated_at TIMESTAMPTZ DEFAULT now()
    );
  `);
}

function normalizeDateParam(value: string | null, fallback: string): string {
  if (!value) return fallback;
  const s = value.slice(0, 10);
  if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return fallback;
  return s;
}

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const regionalRaw = (url.searchParams.get('regional') || '').trim();
    const unidadeRaw = (url.searchParams.get('unidade') || '').trim();

    const now = new Date();
    const defaultAte = now.toISOString().slice(0, 10);
    const defaultDeDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
    const defaultDe = defaultDeDate.toISOString().slice(0, 10);

    let de = normalizeDateParam(url.searchParams.get('de'), defaultDe);
    let ate = normalizeDateParam(url.searchParams.get('ate'), defaultAte);

    if (de > ate) {
      const tmp = de;
      de = ate;
      ate = tmp;
    }

    await ensureEpiEntregasTable();
    await ensureManualColabTable();

    const where: string[] = [];
    const params: any[] = [];

    params.push(de);
    where.push(`j.data >= $${params.length}`);

    params.push(ate);
    where.push(`j.data <= $${params.length}`);

    if (regionalRaw) {
      params.push(regionalRaw.toUpperCase());
      where.push(`upper(coalesce(j.regional, '')) = $${params.length}`);
    }

    if (unidadeRaw) {
      params.push(unidadeRaw.toUpperCase());
      where.push(`upper(coalesce(j.unidade, '')) = $${params.length}`);
    }

    const whereSql = where.length ? `WHERE ${where.join(' AND ')}` : '';

    const sqlBase = `
      WITH base AS (
        SELECT
          e.cpf,
          e.item,
          (elem->>'date')::date AS data,
          (elem->>'qty')::int AS quantidade
        FROM epi_entregas e
        CROSS JOIN LATERAL jsonb_array_elements(e.deliveries) elem
      ),
      joined AS (
        SELECT
          b.cpf,
          b.item,
          b.data,
          COALESCE(f.regional, m.regional, '—') AS regional,
          COALESCE(f.unidade, m.unidade, '—') AS unidade
        FROM base b
        LEFT JOIN mv_alterdata_flat f ON f.cpf = b.cpf
        LEFT JOIN epi_manual_colab m ON m.cpf = b.cpf
      )
    `;

    const sqlUnidade = `
      ${sqlBase}
      SELECT
        j.regional,
        j.unidade,
        COUNT(DISTINCT j.cpf) AS colaboradores,
        COALESCE(SUM(j.quantidade), 0) AS itens_entregues
      FROM joined j
      ${whereSql}
      GROUP BY j.regional, j.unidade
      ORDER BY j.regional, j.unidade;
    `;

    const sqlItem = `
      ${sqlBase}
      SELECT
        j.item,
        COALESCE(SUM(j.quantidade), 0) AS total_itens,
        COUNT(DISTINCT j.cpf) AS colaboradores,
        COUNT(DISTINCT j.unidade) AS unidades
      FROM joined j
      ${whereSql}
      GROUP BY j.item
      ORDER BY total_itens DESC, j.item
      LIMIT 300;
    `;

    const porUnidadeRaw: any[] = await prisma.$queryRawUnsafe<any[]>(sqlUnidade, ...params);
    const porItemRaw: any[] = await prisma.$queryRawUnsafe<any[]>(sqlItem, ...params);

    const porUnidade = (porUnidadeRaw || []).map((r) => {
      const colaboradores = Number(r.colaboradores ?? 0);
      const itens_entregues = Number(r.itens_entregues ?? 0);
      const media_itens = colaboradores > 0 ? itens_entregues / colaboradores : 0;
      return {
        regional: (r.regional || '—').toString(),
        unidade: (r.unidade || '—').toString(),
        colaboradores,
        itens_entregues,
        media_itens,
      };
    });

    const porItem = (porItemRaw || []).map((r) => ({
      item: (r.item || '').toString(),
      total_itens: Number(r.total_itens ?? 0),
      colaboradores: Number(r.colaboradores ?? 0),
      unidades: Number(r.unidades ?? 0),
    }));

    return NextResponse.json({
      ok: true,
      periodo: { de, ate },
      filtros: {
        regional: regionalRaw || null,
        unidade: unidadeRaw || null,
      },
      porUnidade,
      porItem,
    });
  } catch (e: any) {
    return NextResponse.json(
      {
        ok: false,
        error: e?.message || 'Erro ao gerar relatório de entregas.',
        porUnidade: [],
        porItem: [],
      },
      { status: 200 },
    );
  }
}
