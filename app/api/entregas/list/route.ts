export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

type Row = {
  id: string;
  nome: string;
  funcao: string;
  unidade: string;
  regional: string;
  nome_site?: string | null;
};

function onlyDigits(s: string): string {
  return String(s || '').replace(/\D/g, '');
}

async function ensureManualColabTable() {
  // Garante que a tabela de colaboradores manuais exista
  await prisma.$executeRawUnsafe(`
    CREATE TABLE IF NOT EXISTS epi_manual_colab (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      cpf TEXT NOT NULL UNIQUE,
      matricula TEXT,
      nome TEXT,
      funcao TEXT,
      unidade TEXT,
      regional TEXT,
      admissao DATE,
      demissao DATE,
      created_at TIMESTAMPTZ DEFAULT now(),
      updated_at TIMESTAMPTZ DEFAULT now()
    );
  `);
}

export async function GET(req: Request) {
  const url = new URL(req.url);
  const regional = (url.searchParams.get('regional') || '').trim();
  const unidade  = (url.searchParams.get('unidade')  || '').trim();
  const q        = (url.searchParams.get('q')        || '').trim();
  const page     = Math.max(1, parseInt(url.searchParams.get('page') || '1', 10));
  const pageSize = Math.min(200, Math.max(10, parseInt(url.searchParams.get('pageSize') || '25', 10)));

  const regParam = regional;
  const uniParam = unidade;
  const qName    = q ? `%${q.toLowerCase()}%` : '';
  const qCpfRaw  = onlyDigits(q);
  const qCpfLike = qCpfRaw ? `%${qCpfRaw}%` : '';

  const limit  = pageSize;
  const offset = (page - 1) * pageSize;

  try {
    await ensureManualColabTable();

    const sql = `
      WITH base AS (
        -- Colaboradores manuais (que ainda nÃ£o existem na base oficial)
        SELECT
          m.cpf::text      AS cpf,
          m.nome::text     AS nome,
          m.funcao::text   AS funcao,
          m.unidade::text  AS unidade,
          m.regional::text AS regional,
          NULL::text       AS nome_site
        FROM epi_manual_colab m
        LEFT JOIN mv_alterdata_flat a ON a.cpf::text = m.cpf::text
        WHERE a.cpf IS NULL
          AND ($1 = '' OR LOWER(m.regional) = LOWER($1))
          AND ($2 = '' OR LOWER(m.unidade) = LOWER($2))
          AND ($3 = '' OR (LOWER(m.nome) LIKE $3 OR m.cpf LIKE $4))

        UNION ALL

        -- Colaboradores vindos da base Alterdata (view enxuta e indexada)
        SELECT
          a.cpf::text      AS cpf,
          a.nome::text     AS nome,
          a.funcao::text   AS funcao,
          a.unidade::text  AS unidade,
          a.regional::text AS regional,
          NULL::text       AS nome_site
        FROM mv_alterdata_flat a
        WHERE ($1 = '' OR LOWER(a.regional) = LOWER($1))
          AND ($2 = '' OR LOWER(a.unidade) = LOWER($2))
          AND ($3 = '' OR (LOWER(a.nome) LIKE $3 OR a.cpf LIKE $4))
      )
      SELECT
        cpf,
        nome,
        funcao,
        unidade,
        regional,
        nome_site,
        count(*) OVER() AS total_count
      FROM base
      ORDER BY nome
      LIMIT $5 OFFSET $6
    `;

    // @ts-ignore
    const rows: any[] = await prisma.$queryRawUnsafe(sql, regParam, uniParam, qName, qCpfLike, limit, offset);
    const total = rows.length ? Number(rows[0].total_count ?? rows.length) : 0;

    const data: Row[] = rows.map((r) => ({
      id: onlyDigits(r.cpf || '').slice(-11),
      nome: String(r.nome ?? ''),
      funcao: String(r.funcao ?? ''),
      unidade: String(r.unidade ?? ''),
      regional: String(r.regional ?? ''),
      nome_site: r.nome_site ?? null,
    }));

    return NextResponse.json({
      rows: data,
      total,
      page,
      pageSize,
      source: 'mv_alterdata_flat+epi_manual_colab',
    });
  } catch (e: any) {
    return NextResponse.json(
      {
        rows: [] as Row[],
        total: 0,
        page,
        pageSize,
        source: 'error',
        error: e?.message || String(e),
      },
      { status: 200 },
    );
  }
}
