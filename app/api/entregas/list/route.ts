
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { UNID_TO_REGIONAL, canonUnidade } from '@/lib/unidReg';

type Row = {
  id: string;
  nome: string;
  funcao: string;
  unidade: string;
  regional: string;
  nome_site?: string | null;
};

function onlyDigits(s: string): string {
  return String(s || '').replace(/\D/g, '');
}

async function ensureManualColabTable() {
  // Garante a existência da tabela de colaboradores manuais
  await prisma.$executeRawUnsafe(`
    CREATE TABLE IF NOT EXISTS epi_manual_colab (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      cpf TEXT NOT NULL UNIQUE,
      matricula TEXT,
      nome TEXT,
      funcao TEXT,
      unidade TEXT,
      regional TEXT,
      admissao DATE,
      demissao DATE,
      created_at TIMESTAMPTZ DEFAULT now(),
      updated_at TIMESTAMPTZ DEFAULT now()
    );
  `);
}

// Regra de demissão para meta 2025:
// - Remove demitidos antes de 2025-01-01
// - Mantém quem não foi demitido (demissao IS NULL)
// - Mantém demitidos em 2025 (e posteriores)
const DEMISSAO_LIMITE = '2025-01-01';

export async function GET(req: Request) {
  const url = new URL(req.url);
  const regionalFilter = (url.searchParams.get('regional') || '').trim();
  const unidadeFilter  = (url.searchParams.get('unidade')  || '').trim();
  const q              = (url.searchParams.get('q')        || '').trim();

  const page     = Math.max(1, parseInt(url.searchParams.get('page') || '1', 10));
  const pageSize = Math.min(200, Math.max(10, parseInt(url.searchParams.get('pageSize') || '25', 10)));

  const qName    = q ? `%${q.toLowerCase()}%` : '';
  const qCpfRaw  = onlyDigits(q);
  const qCpfLike = qCpfRaw ? `%${qCpfRaw}%` : '';

  const limit  = pageSize;
  const offset = (page - 1) * pageSize;

  try {
    await ensureManualColabTable();

    const sql = `
      WITH base_oficial AS (
        SELECT
          a.cpf::text                AS cpf,
          a.colaborador::text        AS nome,
          a.funcao::text             AS funcao,
          a.unidade_hospitalar::text AS unidade
        FROM stg_alterdata a
        WHERE a.cpf IS NOT NULL
          AND (a.demissao IS NULL OR a.demissao >= $1::date)
      ),
      manual_base AS (
        SELECT
          m.cpf::text     AS cpf,
          m.nome::text    AS nome,
          m.funcao::text  AS funcao,
          m.unidade::text AS unidade
        FROM epi_manual_colab m
        WHERE (m.demissao IS NULL OR m.demissao >= $1::date)
      ),
      manual_only AS (
        SELECT m.*
        FROM manual_base m
        LEFT JOIN base_oficial a ON a.cpf = m.cpf
        WHERE a.cpf IS NULL
      ),
      merged AS (
        SELECT * FROM base_oficial
        UNION ALL
        SELECT * FROM manual_only
      )
      SELECT
        cpf,
        nome,
        funcao,
        unidade,
        COUNT(*) OVER() AS total_count
      FROM merged
      WHERE
        ($2 = '' OR LOWER(unidade) = LOWER($2))
        AND (
          $3 = ''
          OR LOWER(nome) LIKE $3
          OR cpf LIKE $4
        )
      ORDER BY nome
      LIMIT $5 OFFSET $6
    `;

    // @ts-ignore
    const rows: any[] = await prisma.$queryRawUnsafe(sql, DEMISSAO_LIMITE, unidadeFilter, qName, qCpfLike, limit, offset);
    const total = mapped.length;

    // Aplica filtro de Regional e mapeamento no lado da aplicação
    const mapped: Row[] = [];
    for (const r of rows) {
      const unidade = String(r.unidade ?? '');
      let regional = '';

      if (unidade) {
        const canon = canonUnidade(unidade);
        const mappedRegional = (UNID_TO_REGIONAL as any)[canon];
        if (mappedRegional) {
          regional = mappedRegional.charAt(0) + mappedRegional.slice(1).toLowerCase(); // "SUL" -> "Sul"
        }
      }

      if (regionalFilter && regional && regional.toLowerCase() !== regionalFilter.toLowerCase()) {
        continue;
      }

      mapped.push({
        id: onlyDigits(r.cpf || '').slice(-11),
        nome: String(r.nome ?? ''),
        funcao: String(r.funcao ?? ''),
        unidade,
        regional: regional || '—',
        nome_site: null,
      });
    }

    return NextResponse.json({
      rows: mapped,
      total,
      page,
      pageSize,
      source: 'stg_alterdata+epi_manual_colab',
    });
  } catch (e: any) {
    return NextResponse.json(
      {
        rows: [] as Row[],
        total: 0,
        page,
        pageSize,
        source: 'error',
        error: e?.message || String(e),
      },
      { status: 200 },
    );
  }
}
