export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

type Row = {
  id: string;
  nome: string;
  funcao: string;
  unidade: string;
  regional: string;
  nome_site?: string | null;
};

function normUp(v: string): string {
  return (v || '').normalize('NFD').replace(/[^\w]+/g, '').toUpperCase();
}

function onlyDigits(s: string): string {
  return String(s || '').replace(/\D/g, '');
}

async function ensureManualColabTable() {
  await prisma.$executeRawUnsafe(`
    CREATE TABLE IF NOT EXISTS epi_manual_colab (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      cpf TEXT NOT NULL UNIQUE,
      matricula TEXT,
      nome TEXT,
      funcao TEXT,
      unidade TEXT,
      regional TEXT,
      admissao DATE,
      demissao DATE,
      created_at TIMESTAMPTZ DEFAULT now(),
      updated_at TIMESTAMPTZ DEFAULT now()
    );
  `);
}

async function loadFromStaging(
  regional: string,
  unidade: string,
  q: string,
  page: number,
  pageSize: number,
): Promise<{ rows: Row[]; total: number }> {
  await ensureManualColabTable();

  const regParam = regional.trim();
  const uniParam = unidade.trim();
  const qTrim = q.trim();

  const qName = qTrim ? `%${qTrim.toLowerCase()}%` : '';
  const qCpfRaw = onlyDigits(qTrim);
  const qCpfLike = qCpfRaw ? `%${qCpfRaw}%` : '';

  const limit = pageSize;
  const offset = (page - 1) * pageSize;

  const sql = `
    WITH base_oficial AS (
      SELECT
        a.cpf::text      AS cpf,
        a.nome::text     AS nome,
        a.funcao::text   AS funcao,
        a.unidade::text  AS unidade,
        a.regional::text AS regional,
        NULL::text       AS nome_site
      FROM stg_alterdata_v2 a
      WHERE ($1 = '' OR LOWER(a.regional) = LOWER($1))
        AND ($2 = '' OR LOWER(a.unidade) = LOWER($2))
        AND (
          $3 = ''
          OR LOWER(a.nome) LIKE $3
          OR a.cpf LIKE $4
        )
    ),
    base_manual AS (
      SELECT
        m.cpf::text      AS cpf,
        m.nome::text     AS nome,
        m.funcao::text   AS funcao,
        m.unidade::text  AS unidade,
        m.regional::text AS regional,
        NULL::text       AS nome_site
      FROM epi_manual_colab m
      LEFT JOIN stg_alterdata_v2 a ON a.cpf::text = m.cpf::text
      WHERE a.cpf IS NULL
        AND ($1 = '' OR LOWER(m.regional) = LOWER($1))
        AND ($2 = '' OR LOWER(m.unidade) = LOWER($2))
        AND (
          $3 = ''
          OR LOWER(m.nome) LIKE $3
          OR m.cpf LIKE $4
        )
    ),
    base AS (
      SELECT * FROM base_oficial
      UNION ALL
      SELECT * FROM base_manual
    )
    SELECT
      cpf,
      nome,
      funcao,
      unidade,
      regional,
      nome_site,
      COUNT(*) OVER() AS total_count
    FROM base
    ORDER BY nome
    LIMIT $5 OFFSET $6;
  `;

  // @ts-ignore
  const rs: any[] = await prisma.$queryRawUnsafe(
    sql,
    regParam,
    uniParam,
    qName,
    qCpfLike,
    limit,
    offset,
  );

  const total = rs.length ? Number(rs[0].total_count ?? rs.length) : 0;

  const rows: Row[] = rs.map((r) => ({
    id: onlyDigits(r.cpf || '').slice(-11),
    nome: String(r.nome ?? ''),
    funcao: String(r.funcao ?? ''),
    unidade: String(r.unidade ?? ''),
    regional: String(r.regional ?? ''),
    nome_site: r.nome_site ?? null,
  }));

  return { rows, total };
}

// Fallback usando o endpoint antigo de raw-rows caso a tabela stg_alterdata_v2 não exista
async function loadFromLegacyAPI(
  origin: string,
  regional: string,
  unidade: string,
  q: string,
  page: number,
  pageSize: number,
  req: Request,
): Promise<{ rows: Row[]; total: number }> {
  const u = new URL('/api/alterdata/raw-rows', origin);
  u.searchParams.set('page', String(page));
  u.searchParams.set('limit', String(pageSize));
  u.searchParams.set('pageSize', String(pageSize));
  if (regional) u.searchParams.set('regional', regional);
  if (unidade) u.searchParams.set('unidade', unidade);
  if (q) u.searchParams.set('q', q);

  const cookie = req.headers.get('cookie') || '';
  const auth = req.headers.get('authorization') || '';

  const r = await fetch(u.toString(), {
    cache: 'no-store',
    headers: {
      ...(cookie ? { cookie } : {}),
      ...(auth ? { authorization: auth } : {}),
    },
  });

  if (!r.ok) {
    throw new Error(`alterdata/raw-rows ${r.status}`);
  }

  const data = await r.json().catch(() => ({} as any));
  const rawRows = Array.isArray((data as any).rows) ? (data as any).rows : [];
  const flat = rawRows.map((it: any) => ({ row_no: it.row_no, ...(it.data || {}) }));
  const total = Number((data as any).total || flat.length);

  // Heurística igual ao código antigo: tenta descobrir colunas por nome
  const pickKeyByName = (sample: any[], names: string[]): string | null => {
    if (!sample.length) return null;
    const keys = Object.keys(sample[0] || {});
    const norm = (s: string) => s.toLowerCase().normalize('NFD').replace(/[^a-z0-9]+/g, '');
    const wanted = names.map(norm);
    for (const k of keys) {
      const nk = norm(k);
      if (wanted.some((w) => nk.includes(w))) return k;
    }
    return null;
  };

  const cpfKey = pickKeyByName(flat, ['cpf', 'matric', 'cpffunc', 'cpffuncionario']);
  const nomeKey = pickKeyByName(flat, ['nome', 'colab', 'funcionario']);
  const funcKey = pickKeyByName(flat, ['func', 'cargo']);
  const unidKey = pickKeyByName(flat, ['unid', 'lotac', 'setor', 'hosp', 'posto', 'local']);
  const regKey = pickKeyByName(flat, ['regi', 'regional', 'gerencia']);

  let rows: Row[] = flat.map((r) => {
    const idRaw = cpfKey ? r[cpfKey] : '';
    const id = onlyDigits(idRaw).slice(-11);
    const nome = String((nomeKey && r[nomeKey]) ?? '');
    const func = String((funcKey && r[funcKey]) ?? '');
    const un = String((unidKey && r[unidKey]) ?? '');
    const reg = String((regKey && r[regKey]) ?? '');
    return {
      id,
      nome,
      funcao: func,
      unidade: un,
      regional: reg || '—',
      nome_site: null,
    };
  }).filter((x) => x.id || x.nome || x.unidade);

  const nreg = normUp(regional);
  const nuni = normUp(unidade);
  const nq = normUp(q);

  if (nreg) rows = rows.filter((r) => !nreg || normUp(r.regional) === nreg || r.regional === '—');
  if (nuni) rows = rows.filter((r) => normUp(r.unidade) === nuni);
  if (nq) rows = rows.filter((r) => normUp(r.nome).includes(nq) || normUp(r.id).includes(nq));

  rows.sort((a, b) => a.nome.localeCompare(b.nome));
  const start = (page - 1) * pageSize;
  const pageRows = rows.slice(start, start + pageSize);

  return { rows: pageRows, total: rows.length };
}

export async function GET(req: Request) {
  const url = new URL(req.url);

  const regional = url.searchParams.get('regional') || '';
  const unidade = url.searchParams.get('unidade') || '';
  const q = url.searchParams.get('q') || '';
  const page = Math.max(1, parseInt(url.searchParams.get('page') || '1', 10));
  const pageSize = Math.min(200, Math.max(10, parseInt(url.searchParams.get('pageSize') || '25', 10)));

  try {
    let result: { rows: Row[]; total: number };

    try {
      // Caminho rápido: tabela stg_alterdata_v2
      result = await loadFromStaging(regional, unidade, q, page, pageSize);
    } catch (e) {
      // Fallback para a API legacy se a tabela ainda não existir
      result = await loadFromLegacyAPI(url.origin, regional, unidade, q, page, pageSize, req);
    }

    return NextResponse.json({
      rows: result.rows,
      total: result.total,
      page,
      pageSize,
      source: 'entregas:list',
    });
  } catch (e: any) {
    return NextResponse.json(
      {
        rows: [] as Row[],
        total: 0,
        page,
        pageSize,
        source: 'error',
        error: e?.message || String(e),
      },
      { status: 200 },
    );
  }
}
